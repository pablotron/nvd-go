
// Enumerated string type tests.
//
// Automatically generated by `gen-enums.rb`.
package v2

import (
  "testing"
)


// Access Vector tests
func TestAccessVector(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val AccessVector // test value
      exp string // expected string
    } {{ AVNetwork, "NETWORK" }, { AVAdjacentNetwork, "ADJACENT_NETWORK" }, { AVLocal, "LOCAL" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val AccessVector // test value
    } {
      { "invalid", InvalidAccessVector },
      { "garbage", AccessVector(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp AccessVector // expected result
    } {{ "NETWORK", AVNetwork }, { "ADJACENT_NETWORK", AVAdjacentNetwork }, { "LOCAL", AVLocal }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got AccessVector
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got AccessVector
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val AccessVector // test value
      exp string // expected string
    } {{ AVNetwork, "NETWORK" }, { AVAdjacentNetwork, "ADJACENT_NETWORK" }, { AVLocal, "LOCAL" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val AccessVector // test value
    } {
      { "invalid", InvalidAccessVector },
      { "garbage", AccessVector(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Access Complexity tests
func TestAccessComplexity(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val AccessComplexity // test value
      exp string // expected string
    } {{ ACHigh, "HIGH" }, { ACMedium, "MEDIUM" }, { ACLow, "LOW" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val AccessComplexity // test value
    } {
      { "invalid", InvalidAccessComplexity },
      { "garbage", AccessComplexity(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp AccessComplexity // expected result
    } {{ "HIGH", ACHigh }, { "MEDIUM", ACMedium }, { "LOW", ACLow }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got AccessComplexity
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got AccessComplexity
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val AccessComplexity // test value
      exp string // expected string
    } {{ ACHigh, "HIGH" }, { ACMedium, "MEDIUM" }, { ACLow, "LOW" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val AccessComplexity // test value
    } {
      { "invalid", InvalidAccessComplexity },
      { "garbage", AccessComplexity(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Authentication tests
func TestAuthentication(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Authentication // test value
      exp string // expected string
    } {{ AMultiple, "MULTIPLE" }, { ASingle, "SINGLE" }, { ANone, "NONE" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Authentication // test value
    } {
      { "invalid", InvalidAuthentication },
      { "garbage", Authentication(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp Authentication // expected result
    } {{ "MULTIPLE", AMultiple }, { "SINGLE", ASingle }, { "NONE", ANone }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got Authentication
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got Authentication
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Authentication // test value
      exp string // expected string
    } {{ AMultiple, "MULTIPLE" }, { ASingle, "SINGLE" }, { ANone, "NONE" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Authentication // test value
    } {
      { "invalid", InvalidAuthentication },
      { "garbage", Authentication(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Cia tests
func TestCia(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Cia // test value
      exp string // expected string
    } {{ CNone, "NONE" }, { CPartial, "PARTIAL" }, { CComplete, "COMPLETE" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Cia // test value
    } {
      { "invalid", InvalidCia },
      { "garbage", Cia(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp Cia // expected result
    } {{ "NONE", CNone }, { "PARTIAL", CPartial }, { "COMPLETE", CComplete }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got Cia
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got Cia
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Cia // test value
      exp string // expected string
    } {{ CNone, "NONE" }, { CPartial, "PARTIAL" }, { CComplete, "COMPLETE" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Cia // test value
    } {
      { "invalid", InvalidCia },
      { "garbage", Cia(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Exploitability tests
func TestExploitability(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Exploitability // test value
      exp string // expected string
    } {{ EUnproven, "UNPROVEN" }, { EProofOfConcept, "PROOF_OF_CONCEPT" }, { EFunctional, "FUNCTIONAL" }, { EHigh, "HIGH" }, { ENotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Exploitability // test value
    } {
      { "invalid", InvalidExploitability },
      { "garbage", Exploitability(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp Exploitability // expected result
    } {{ "UNPROVEN", EUnproven }, { "PROOF_OF_CONCEPT", EProofOfConcept }, { "FUNCTIONAL", EFunctional }, { "HIGH", EHigh }, { "NOT_DEFINED", ENotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got Exploitability
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got Exploitability
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val Exploitability // test value
      exp string // expected string
    } {{ EUnproven, "UNPROVEN" }, { EProofOfConcept, "PROOF_OF_CONCEPT" }, { EFunctional, "FUNCTIONAL" }, { EHigh, "HIGH" }, { ENotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val Exploitability // test value
    } {
      { "invalid", InvalidExploitability },
      { "garbage", Exploitability(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Remediation Level tests
func TestRemediationLevel(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val RemediationLevel // test value
      exp string // expected string
    } {{ RLOfficialFix, "OFFICIAL_FIX" }, { RLTemporaryFix, "TEMPORARY_FIX" }, { RLWorkaround, "WORKAROUND" }, { RLUnavailable, "UNAVAILABLE" }, { RLNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val RemediationLevel // test value
    } {
      { "invalid", InvalidRemediationLevel },
      { "garbage", RemediationLevel(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp RemediationLevel // expected result
    } {{ "OFFICIAL_FIX", RLOfficialFix }, { "TEMPORARY_FIX", RLTemporaryFix }, { "WORKAROUND", RLWorkaround }, { "UNAVAILABLE", RLUnavailable }, { "NOT_DEFINED", RLNotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got RemediationLevel
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got RemediationLevel
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val RemediationLevel // test value
      exp string // expected string
    } {{ RLOfficialFix, "OFFICIAL_FIX" }, { RLTemporaryFix, "TEMPORARY_FIX" }, { RLWorkaround, "WORKAROUND" }, { RLUnavailable, "UNAVAILABLE" }, { RLNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val RemediationLevel // test value
    } {
      { "invalid", InvalidRemediationLevel },
      { "garbage", RemediationLevel(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Report Confidence tests
func TestReportConfidence(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val ReportConfidence // test value
      exp string // expected string
    } {{ RCUnconfirmed, "UNCONFIRMED" }, { RCUncorroborated, "UNCORROBORATED" }, { RCConfirmed, "CONFIRMED" }, { RCNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val ReportConfidence // test value
    } {
      { "invalid", InvalidReportConfidence },
      { "garbage", ReportConfidence(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp ReportConfidence // expected result
    } {{ "UNCONFIRMED", RCUnconfirmed }, { "UNCORROBORATED", RCUncorroborated }, { "CONFIRMED", RCConfirmed }, { "NOT_DEFINED", RCNotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got ReportConfidence
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got ReportConfidence
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val ReportConfidence // test value
      exp string // expected string
    } {{ RCUnconfirmed, "UNCONFIRMED" }, { RCUncorroborated, "UNCORROBORATED" }, { RCConfirmed, "CONFIRMED" }, { RCNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val ReportConfidence // test value
    } {
      { "invalid", InvalidReportConfidence },
      { "garbage", ReportConfidence(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Collateral Damage Potential tests
func TestCollateralDamagePotential(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val CollateralDamagePotential // test value
      exp string // expected string
    } {{ CDPNone, "NONE" }, { CDPLow, "LOW" }, { CDPLowMedium, "LOW_MEDIUM" }, { CDPMediumHigh, "MEDIUM_HIGH" }, { CDPHigh, "HIGH" }, { CDPNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val CollateralDamagePotential // test value
    } {
      { "invalid", InvalidCollateralDamagePotential },
      { "garbage", CollateralDamagePotential(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp CollateralDamagePotential // expected result
    } {{ "NONE", CDPNone }, { "LOW", CDPLow }, { "LOW_MEDIUM", CDPLowMedium }, { "MEDIUM_HIGH", CDPMediumHigh }, { "HIGH", CDPHigh }, { "NOT_DEFINED", CDPNotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got CollateralDamagePotential
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got CollateralDamagePotential
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val CollateralDamagePotential // test value
      exp string // expected string
    } {{ CDPNone, "NONE" }, { CDPLow, "LOW" }, { CDPLowMedium, "LOW_MEDIUM" }, { CDPMediumHigh, "MEDIUM_HIGH" }, { CDPHigh, "HIGH" }, { CDPNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val CollateralDamagePotential // test value
    } {
      { "invalid", InvalidCollateralDamagePotential },
      { "garbage", CollateralDamagePotential(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Target Distribution tests
func TestTargetDistribution(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val TargetDistribution // test value
      exp string // expected string
    } {{ TDNone, "NONE" }, { TDLow, "LOW" }, { TDMedium, "MEDIUM" }, { TDHigh, "HIGH" }, { TDNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val TargetDistribution // test value
    } {
      { "invalid", InvalidTargetDistribution },
      { "garbage", TargetDistribution(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp TargetDistribution // expected result
    } {{ "NONE", TDNone }, { "LOW", TDLow }, { "MEDIUM", TDMedium }, { "HIGH", TDHigh }, { "NOT_DEFINED", TDNotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got TargetDistribution
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got TargetDistribution
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val TargetDistribution // test value
      exp string // expected string
    } {{ TDNone, "NONE" }, { TDLow, "LOW" }, { TDMedium, "MEDIUM" }, { TDHigh, "HIGH" }, { TDNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val TargetDistribution // test value
    } {
      { "invalid", InvalidTargetDistribution },
      { "garbage", TargetDistribution(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    

// Cia Requirement tests
func TestCiaRequirement(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val CiaRequirement // test value
      exp string // expected string
    } {{ CRLow, "LOW" }, { CRMedium, "MEDIUM" }, { CRHigh, "HIGH" }, { CRNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val CiaRequirement // test value
    } {
      { "invalid", InvalidCiaRequirement },
      { "garbage", CiaRequirement(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp CiaRequirement // expected result
    } {{ "LOW", CRLow }, { "MEDIUM", CRMedium }, { "HIGH", CRHigh }, { "NOT_DEFINED", CRNotDefined }}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got CiaRequirement
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %v, exp %v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got CiaRequirement
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val CiaRequirement // test value
      exp string // expected string
    } {{ CRLow, "LOW" }, { CRMedium, "MEDIUM" }, { CRHigh, "HIGH" }, { CRNotDefined, "NOT_DEFINED" }}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \"%s\", exp \"%s\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val CiaRequirement // test value
    } {
      { "invalid", InvalidCiaRequirement },
      { "garbage", CiaRequirement(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \"%s\", exp \"\"", got)
        }
      })
    }
  })
}
    
    