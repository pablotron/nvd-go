{{ $offsets := .offsets }}
// Enumerated CVSS vector components.
//
// Automatically generated by "gen-vector.go".
package {{.ns}}

import "fmt"

// Invalid type string error
type invalidTypeString struct {
  Type, Value string
}

func newInvalidTypeString(typeName, value string) *InvalidTypeString {
  return &InvalidTypeString { typeName, value }
}

func (t invalidTypeString) Error() string {
  return fmt.Sprintf("invalid %s: \\"%s\\"", t.Type, t.Value)
}

// packed string of enumeration strings
const pack = "{{.pack}}"

// TODO: key ID and Name offsets

{{ range .enums }}
// {{ .Name }}
type {{ .Name }} uint8
const (
  {{ $id := .Id }}
  {{ .Id }}_Nil {{ .Name }} = iota,
  {{ range .Values }}
    {{ $id }}_{{ .Name }}, // {{ .Title }}
  {{ end }}
  {{ .Id }}_Final
)

// Convert {{ .Name }} to string.
func (v {{ .Name }}) String() string {
  switch v {
  {{ range .Values }}
  case {{ $id }}_{{ .Name }}:
    return pack[{{ index $offsets .Name }}:({{ index $offsets .Name }}+{{ len .Name }})]
  {{ end }}
  default:
    return ""
  }
}
{{ end }}

// offset and length of Key strings in packed string.
const keys = [...]struct {
  idOfs, idLen uint16
  nameOfs, nameLen uint16
} {
  { 0, 0, 0, 0 }, // invalidKey
{{ range .keys }}
  { {{ index $offsets .Id }}, {{ len .Id }}, {{ index $offsets .Name }}, {{ len .Name }} },  // {{ .Name }}
{{ end }}
}

// Vector element key.
type Key uint8
const (
  invalidKey Key = iota,
{{ range .keys }}
  {{ .Id }}, // {{ .Name }}
{{ end }}
  lastKey
)

// Convert Key to string.
func (k Key) String() string {
  if k < lastKey {
    d := keys[uint8(k)]
    return pack[d.idOfs:(d.idOfs+d.idLen)]
  } else {
    return ""
  }
}

// Convert Key to name string.
func (k Key) Name() string {
  if k < lastKey {
    d := keys[uint8(k)]
    return pack[d.nameOfs:(d.nameOfs+d.nameLen)]
  } else {
    return ""
  }
}

// offset and length of Value strings in packed string.
const values = [...]struct {
  idOfs, idLen uint16
  nameOfs, nameLen uint16
} {
  { 0, 0, 0, 0 }, // invalidValue
{{ range .vals }}
  { {{ index $offsets .Id }}, {{ len .Id }}, {{ index $offsets .Name }}, {{ len .Name }} },  // {{ .Name }}
{{ end }}
}

// Vector element value.
type Value uint8
const (
  invalidValue Value = iota,
{{ range .vals }}
  {{ .Name }}, // {{ .Id }}
{{ end }}
  lastValue
)

// Convert Value to ID string.
func (v Value) String() string {
  if v < lastValue {
    d := values[uint8(v)]
    return pack[d.idOfs:(d.idOfs+d.idLen)]
  } else {
    return ""
  }
}

// Convert Value to name string.
func (v Value) Name() string {
  if v < lastValue {
    d := values[uint8(v)]
    return pack[d.nameOfs:(d.nameOfs + d.nameLen)]
  } else {
    return ""
  }
}

const elements = [...]struct {
  Key Key
  Value Value
  strOfs, strLen uint16
} {
  { invalidKey, invalidValue, 0, 0 },
{{ range .keys }}
  {{ $id := .Id }}
  {{ $name := .Name }}
  {{ range .Enum.Values }}
    { {{ $id }}, {{ .Name }}, {{ index $offsets (printf "%s:%s" $id .Id)}}, ({{ len $id }} + 1 + {{ len .Id }}) }, // {{ $id }}_{{ .Id }}
  {{ end }}
{{ end }}
}

// Single element of vector which contains a key/value pair.
type Element uint8

const (
  invalidElement Element = iota,
{{ range .keys }}
  {{ $id := .Id }}
  {{ $name := .Name }}
  {{ range .Enum.Values }}
    {{ $id }}_{{ .Id }}, // {{ $id }}:{{ .Id }} ({{ $name }}: {{ .Name }})
  {{ end }}
{{ end }}
  lastElement
)

// Get element key.
func (e Element) Key() Key {
  if uint8(e) < lastElement {
    return elements[uint8(e)].Key
  } else {
    return invalidKey
  }
}

// Get element value.
func (e Element) Value() Value {
  if uint8(e) < lastElement {
    return elements[uint8(e)].Value
  } else {
    return invalidValue
  }
}

// Convert element to string.
func (e Element) String() string {
  if uint8(e) < lastElement {
    d := elements[uint8(e)]
    return pack[d.strOfs:(d.strOfs + d.strLen)]
  } else {
    return ""
  }
}

// CVSS v3.1 vector.
//
// Vector is packed as an unsigned, 64-bit integer.
type Vector uint64

const packedElements = [...]Element {
{{ range .keys }}
  // {{ .Id }}
  {{ range $i, $e := packed_elements .Id .Enum.Values }}
    {{ $e }},
  {{ end }}
{{ end }}
}

// Return list of vector elements.
func (v Vector) Elements []Element {
  r := make([]Element, 0, {{len .keys}})

{{ range $i, $k := .keys }}
  // {{ $k.Id }}
  if val := (uint64(v) >> {{$k.Shift}}) & ((1 << {{$k.Mask}}) - 1); val > 0 {
    r = append(r, packedElements[({{ $i }} << 3) + val])
  }
{{ end }}

  return r
}

// Return vector as string
func (v Vector) String() string {
  r := []string { "CVSS:3.1" }

  for e := range(v.Elements()) {
    r := append(r, e.String())
  }

  // build result
  return strings.Join(r, "/")
}
