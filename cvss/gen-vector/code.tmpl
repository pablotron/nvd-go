{{ $offsets := .Offsets }}
{{ $defs := .Defs }}
// CVSS v{{.Version}} key, value, metrics, and vectors.
//
// Automatically generated by "cvss/gen-vector/gen.go".
package {{.Ns}}

import (
  "encoding/json"
  "fmt"
  "pablotron.org/nvd-go/cvss"
  "regexp"
  "strings"

)

// packed strings
const pack = "{{.Pack}}"

// offset and length of packed Key strings
var keys = [...]struct {
  idOfs, idLen uint16 // id string offset and length
  nameOfs, nameLen uint16 // name string offset and length
} {
  { 0, 0, 0, 0 }, // invalidKey
{{- range .Keys }}
  { {{ index $offsets .Id }}, {{ len .Id }}, {{ index $offsets .Name }}, {{ len .Name }} },  // {{ .Name }}
{{- end }}
}

// Metric key.
type Key uint8
const (
  invalidKey Key = iota
{{- range .Keys }}
  {{ .Id }} // {{ .Name }}
{{- end }}
  lastKey
)

// Convert Key to string.
func (k Key) String() string {
  if uint8(k) < uint8(lastKey) {
    d := keys[uint8(k)]
    return pack[d.idOfs:(d.idOfs+d.idLen)]
  } else {
    return ""
  }
}

// Convert Key to name string.
func (k Key) Name() string {
  if uint8(k) < uint8(lastKey) {
    d := keys[uint8(k)]
    return pack[d.nameOfs:(d.nameOfs+d.nameLen)]
  } else {
    return ""
  }
}

// offset and length of ID and name strings in packed string.
var values = [...]struct {
  idOfs, idLen uint16
  nameOfs, nameLen uint16
} {
  { 0, 0, 0, 0 }, // invalidValue
{{- range .Vals }}
  { {{ index $offsets .Id }}, {{ len .Id }}, {{ index $offsets .Name }}, {{ len .Name }} }, // {{ .Name }}
{{- end }}
}

// Metric value.
type Value uint8
const (
  invalidValue Value = iota
{{- range .Vals }}
  {{ .Name }} // {{ .Id }}
{{- end }}
  lastValue
)

// Convert Value to ID string.
func (v Value) String() string {
  if uint8(v) < uint8(lastValue) {
    d := values[uint8(v)]
    return pack[d.idOfs:(d.idOfs+d.idLen)]
  } else {
    return ""
  }
}

// Convert Value to name string.
func (v Value) Name() string {
  if uint8(v) < uint8(lastValue) {
    d := values[uint8(v)]
    return pack[d.nameOfs:(d.nameOfs + d.nameLen)]
  } else {
    return ""
  }
}

// metrics
var metrics = [...]struct {
  Key Key // metric key
  Value Value // metric value
  strOfs, strLen uint16 // offset and length of packed metric strings
} {
  { invalidKey, invalidValue, 0, 0 }, // invalidMetric
{{- range .Keys }}
  {{- $id := .Id -}}
  {{- $name := .Name -}}
  {{- $enum := index $defs .Enum -}}
  {{- range $enum.Values }}
    { {{ $id }}, {{ .Name }}, {{ index $offsets (printf "%s:%s" $id .Id)}}, ({{ len $id }} + 1 + {{ len .Id }}) }, // {{ $id }}_{{ .Id }}
  {{- end }}
{{- end }}
}

// Single metric.
type Metric uint8

const (
  invalidMetric Metric = iota
{{- range .Keys }}
  {{- $id := .Id -}}
  {{- $name := .Name -}}
  {{- $enum := index $defs .Enum -}}
  {{- range $enum.Values }}
    {{ $id }}_{{ .Id }} // {{ $id }}:{{ .Id }} ({{ $name }}: {{ .Name }})
  {{- end }}
{{- end }}
  lastMetric
)

// Get metric key.
func (m Metric) Key() Key {
  if uint8(m) < uint8(lastMetric) {
    return metrics[uint8(m)].Key
  } else {
    return invalidKey
  }
}

// Get metric value.
func (m Metric) Value() Value {
  if uint8(m) < uint8(lastMetric) {
    return metrics[uint8(m)].Value
  } else {
    return invalidValue
  }
}

// Convert metric to string.
func (m Metric) String() string {
  if uint8(m) < uint8(lastMetric) {
    d := metrics[uint8(m)]
    return pack[d.strOfs:(d.strOfs + d.strLen)]
  } else {
    return ""
  }
}

// CVSS v{{.Version}} vector.
//
// Vector metrics are packed into a single unsigned, 64-bit integer.
type Vector uint64

// Map of packed metric value to metric constant.  Used by Metrics()
// to unpack a packed vector.
var packedMetrics = [...]Metric {
{{- range .Keys -}}
  // {{ .Id }}
  {{- $enum := index $defs .Enum }}
  {{ range $i, $m := packed_metrics .Id $enum.Values -}}
    {{ $m }},
  {{ end -}}
{{- end -}}
}

// Return list of vector metrics.
func (v Vector) Metrics() []Metric {
  // allocate result
  r := make([]Metric, 0, {{len .Keys}})

{{- range $i, $k := .Keys }}
  // {{ $k.Id }}
  if val := (uint64(v) >> {{$k.Shift}}) & ((1 << {{$k.Mask}}) - 1); val > 0 {
    r = append(r, packedMetrics[({{ $i }} << 3) + val])
  }
{{- end }}

  // return result
  return r
}

// CVSS v{{.Version}} vector prefix
const prefix = "CVSS:{{.Version}}"

// Return vector as string
func (v Vector) String() string {
  r := []string { {{ if ne .Ns "v2" }}prefix{{ end }} }

  for _, m := range(v.Metrics()) {
    r = append(r, m.String())
  }

  // build result
  return strings.Join(r, "/")
}

// map of metric string to shift, mask, and value
var metricStrs = map[string]struct {
  shift, mask uint8 // shift/mask
  val uint8 // encoded value
} {
{{- range .Keys }}
  {{- $k := . -}}
  {{- $enum := index $defs .Enum -}}
  {{- range $i, $v := $enum.Values }}
    "{{ $k.Id }}:{{ $v.Id }}": { {{ $k.Shift }}, {{ $k.Mask }}, {{ $i }} + 1 },
  {{- end -}}
{{ end }}
}

// Parse string into CVSS v{{.Version}} vector.
func ParseVector(s string) (Vector, error) {
  // split string into prefix and metrics
  parts := strings.Split(s, "/")
  if len(parts) < 2 {
    return Vector(0), fmt.Errorf("missing prefix: \"%s\"", s)
  }

{{ if eq .Ns "v2" }}
  // v2 metrics have no prefix
  metricParts := parts
{{ else }}
  // check prefix
  if parts[0] != prefix {
    return Vector(0), fmt.Errorf("invalid prefix: \"%s\"", parts[0])
  }

  // skip prefix
  metricParts := parts[1:]
{{- end }}

  // parse metrics, build result
  r := uint64(0)
  for _, ms := range(metricParts) {
    // parse metric string
    d, ok := metricStrs[ms]
    if !ok {
      return Vector(0), fmt.Errorf("unknown metric: \"%s\"", ms)
    }

    // check for duplicate metrics
    if (r & (((1 << uint64(d.mask)) - 1) << uint64(d.shift))) != 0 {
      return Vector(0), fmt.Errorf("duplicate metric: \"%s\"", ms)
    }

    // add to result
    r |= uint64(d.val) << uint64(d.shift) // set value
  }

  // return result
  return Vector(r), nil
}

// Parse string into CVSS v{{.Version}} vector or panic on error.
func MustParseVector(s string) Vector {
  if v, err := ParseVector(s); err == nil {
    return v
  } else {
    panic(err)
  }
}

// Unmarshal vector from text.
func (v *Vector) UnmarshalText(b []byte) error {
  if nv, err := ParseVector(string(b)); err != nil {
    return err
  } else {
    *v = nv
    return nil
  }
}

// Marshal vector as JSON string.
func (v *Vector) MarshalJSON() ([]byte, error) {
  return json.Marshal(v.String())
}

// Get vector version.
func (v Vector) Version() cvss.Version {
  return cvss.{{.VersionConst}}
}

// vector string regex (from JSON schema)
var matchPattern = regexp.MustCompile("{{.Pattern}}")

// Returns true if the given string is a valid CVSS v{{.Version}} string.
func ValidVectorString(s string) bool {
  return matchPattern.MatchString(s)
}
