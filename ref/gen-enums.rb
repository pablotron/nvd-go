#!/usr/bin/env ruby
# frozen_string_literal: true

#
# gen-enums.rb: generate code and tests enumerated string values from
# JSON schema given on standard input.
#
# Example:
#   # regenerate cvss/v2/enums{,_test}.go from ref/cvss-v2.0.json
#   ./gen-enums.rb v2 < cvss-v2.0.json
#
# TODO: should be rewritten to work with `go generate`.
#

# load libraries
require 'json'
require 'digest/sha2'

# templates
T = {
  code: {
    main: %{
// Enumerated string types.
//
// Automatically generated by `gen-enums.rb`.
package %<ns>s

import "fmt"

// packed string of enumeration values
const %<pack>s = `%<pack_data>s`

%<enums>s
},

    enum_name: '%<type_acronym>s%<name>s',

    enum: %(
// %<comment>s
type %<type>s uint8

const (
  Invalid%<type>s %<type>s = iota%<consts>s
)

// Convert %<type>s to string.
func (v %<type>s) String() string {
  switch v {%<string_cases>s
  default:
    return ""
  }
}

// Unmarshal %<type>s from text.
func (v *%<type>s) UnmarshalText(text []byte) error {
  s := string(text)
  switch string(text) {%<unmarshal_cases>s
  default:
    return fmt.Errorf("invalid %<type>s: \\"%%s\\"", s)
  }
}

// Marshal %<type>s to text.
func (v *%<type>s) MarshalText() ([]byte, error) {
  return []byte(v.String()), nil
}
),

    const: %{
  %<name>s},

    parse_case: %{
  case "%<val>s":
    return %<name>s, nil},

    string_case: %{
  case %<name>s:
    return %<pack>s[%<pack_lo>d:%<pack_hi>d]},

    unmarshal_case: %{
  case "%<val>s":
    *v = %<name>s
    return nil},
  },

  test: {
    main: %{
// Enumerated string type tests.
//
// Automatically generated by `gen-enums.rb`.
package %<ns>s

import (
  "testing"
)

%<enums>s
    },

    enum: %{
// %<comment>s tests
func Test%<type>s(t *testing.T) {
  t.Run("String", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val %<type>s // test value
      exp string // expected string
    } {%<string_cases>s}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        got := test.val.String()
        if got != test.exp {
          t.Fatalf("got \\"%%s\\", exp \\"%%s\\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val %<type>s // test value
    } {
      { "invalid", Invalid%<type>s },
      { "garbage", %<type>s(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        got := test.val.String()
        if got != "" {
          t.Fatalf("got \\"%%s\\", exp \\"\\"", got)
        }
      })
    }
  })

  t.Run("UnmarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val string // test value
      exp %<type>s // expected result
    } {%<unmarshal_cases>s}

    for _, test := range(passTests) {
      t.Run(test.val, func(t *testing.T) {
        var got %<type>s
        if err := got.UnmarshalText([]byte(test.val)); err != nil {
          t.Fatal(err)
        }

        if got != test.exp {
          t.Fatalf("got %%v, exp %%v", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val string // test value
    } {
      { "empty", "" },
      { "garbage", "junk" },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        var got %<type>s
        if err := got.UnmarshalText([]byte(test.val)); err == nil {
          t.Fatalf("got %%v, exp error", got)
        }
      })
    }
  })

  t.Run("MarshalText", func(t *testing.T) {
    // tests expected to pass
    passTests := []struct {
      val %<type>s // test value
      exp string // expected string
    } {%<string_cases>s}

    for _, test := range(passTests) {
      t.Run(test.exp, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != test.exp {
          t.Fatalf("got \\"%%s\\", exp \\"%%s\\"", got, test.exp)
        }
      })
    }

    // tests expected to fail
    failTests := []struct {
      name string // test name
      val %<type>s // test value
    } {
      { "invalid", Invalid%<type>s },
      { "garbage", %<type>s(255) },
    }

    for _, test := range(failTests) {
      t.Run(test.name, func(t *testing.T) {
        gotBytes, err := test.val.MarshalText()
        if err != nil {
          t.Fatal(err)
        }

        got := string(gotBytes)
        if got != "" {
          t.Fatalf("got \\"%%s\\", exp \\"\\"", got)
        }
      })
    }
  })
}
    },

    string_case: %{{ %<name>s, "%<val>s" }},
    unmarshal_case: %{{ "%<val>s", %<name>s }},
  },
}.freeze

class Type
  attr_reader :id, :title, :acronym, :comment

  def initialize(id)
    # remove "Type" suffix
    id = id.gsub(/Type$/, '')

    # build title
    @title = id.dup
    @title[0] = id[0].upcase

    # build comment
    @comment = id.size.times.each_with_object([]) do |i, r|
      c = id[i]
      u = c.upcase

      if i == 0
        r << u
      elsif c == u
        r << " #{u}"
      else
        r << c
      end
    end.join

    # build acronym
    @acronym = id.size.times.each_with_object([]) do |i, r|
      c = id[i]
      r << c.upcase if ((i == 0) || c == c.upcase)
    end.join
  end
end

#
# Build packed string of enum string values.
#
# Works by sorting enum values by length from longest to shortest; by
# definition if there are overlapping strings then shorter strings will
# will be subsets of longer strings
#
def to_packed(enums)
  # build list of unique string enum vals
  strs = enums.values.map { |row| row['enum'] }.flatten.uniq

  # build packed string of enum vals
  strs.sort { |a, b| b.size <=> a.size }.reduce('') do |r, k|
    r.index(k) ? r : (r + k)
  end
end

# get namespace from command-line args
NS = ARGV.shift
raise "Usage: #$0 <ns>" unless NS

# build path to destination directory and destination paths
DST_PATHS = {
  code: File.join(__dir__, '..', 'cvss', NS, 'enums.go'),
  test: File.join(__dir__, '..', 'cvss', NS, 'enums_test.go'),
}

# read data from stdin
DATA = STDIN.read

# read enums from schema definitions
enums = JSON(DATA)['definitions'].select { |id, row|
  # limit to enumerated string types
  row['type'] == 'string' && row.key?('enum')
}.freeze

# build pack name and pack data
pack = '_pack_%s' % [Digest::SHA256.hexdigest(DATA)[0,32]]
PACK_DATA = to_packed(enums)

# write "enums.go"
File.write(DST_PATHS[:code], T[:code][:main] % {
  # package namespace
  ns: NS,

  # name and data for packed string
  pack: pack,
  pack_data: PACK_DATA,

  enums: enums.map { |id, row|
    # parse type from ID
    type = Type.new(id)

    vals = row['enum'].map { |val|
      # build enumeration name
      enum_name = T[:code][:enum_name] % {
        type_acronym: type.acronym,
        name: val.split('_').map { |s|
          s.downcase.capitalize
        }.join,
      }

      {
        pack: pack,
        type: type.title,
        comment: type.comment,
        val: val,
        pack_lo: PACK_DATA.index(val),
        pack_hi: PACK_DATA.index(val) + val.size,
        name: enum_name,
      }
    }

    T[:code][:enum] % {
      type: type.title,
      comment: type.comment,
      consts: vals.map { |val| T[:code][:const] % val }.join,
      parse_cases: vals.map { |val| T[:code][:parse_case] % val }.join,
      string_cases: vals.map { |val| T[:code][:string_case] % val }.join,
      unmarshal_cases: vals.map { |val| T[:code][:unmarshal_case] % val }.join,
    }
  }.join("\n"),
})

# write "enums_test.go"
File.write(DST_PATHS[:test], T[:test][:main] % {
  # package namespace
  ns: NS,

  enums: enums.map { |id, row|
    # parse type from ID
    type = Type.new(id)

    vals = row['enum'].map { |val|
      # build enumeration name
      enum_name = T[:code][:enum_name] % {
        type_acronym: type.acronym,
        name: val.split('_').map { |s|
          s.downcase.capitalize
        }.join,
      }

      { name: enum_name, val: val }
    }

    T[:test][:enum] % {
      type: type.title,
      comment: type.comment,
      string_cases: vals.map { |val| T[:test][:string_case] % val }.join(', '),
      unmarshal_cases: vals.map { |val| T[:test][:unmarshal_case] % val }.join(', '),
    }
  }.join("\n"),
})
