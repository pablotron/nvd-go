package nvd_api

import (
  "encoding/json"
  "github.com/google/uuid"
  "pmdn.org/nvd-go/cvss"
  "pmdn.org/nvd-go/rfc3339"
  "pmdn.org/nvd-go/nvd-api/cvss31"
  "reflect"
  "testing"
)

func TestVulnerabilityUnmarshalJSON(t *testing.T) {
  // read cve data
  data := readTestData(t, "testdata/cve-2022-44006.json.gz")

  // unmarshal vulnerability
  var v Vulnerability
  if err := json.Unmarshal(data, &v); err != nil {
    t.Fatal(err)
  }

  t.Run("cve id", func(t *testing.T) {
    exp := "CVE-2022-44006"
    got := v.Cve.Id.String()
    if got != exp {
      t.Fatalf("got %s, exp %s", got, exp)
    }
  })

  t.Run("source identifier", func(t *testing.T) {
    exp := "cve@mitre.org"
    got := *v.Cve.SourceIdentifier
    if got != exp {
      t.Fatalf("got %s, exp %s", got, exp)
    }
  })

  t.Run("published", func(t *testing.T) {
    exp := *rfc3339.MustParseDateTime("2022-11-16T23:15:12.870")
    got := v.Cve.Published
    if got != exp {
      t.Fatalf("got %v, exp %v", got, exp)
    }
  })

  t.Run("last modified", func(t *testing.T) {
    exp := *rfc3339.MustParseDateTime("2022-11-20T14:02:24.783")
    got := v.Cve.LastModified
    if got != exp {
      t.Fatalf("got %v, exp %v", got, exp)
    }
  })

  t.Run("vulnStatus", func(t *testing.T) {
    exp := "Analyzed"
    got := *v.Cve.VulnStatus
    if got != exp {
      t.Fatalf("got %s, exp %s", got, exp)
    }
  })

  t.Run("descriptions", func(t *testing.T) {
    exp := []LangString {
      LangString {
        Lang: "en",
        Value: "An issue was discovered in BACKCLICK Professional 5.9.63. Due to improper validation or sanitization of upload filenames, an externally reachable, unauthenticated update function permits writing files outside the intended target location. Achieving remote code execution is possible, e.g., by uploading an executable file.",
      },
    }

    got := v.Cve.Descriptions
    if !reflect.DeepEqual(got, exp) {
      t.Fatalf("got %v, exp %v", got, exp)
    }
  })

  t.Run("CvssMetricV31", func(t *testing.T) {
    {
      // check metric length
      exp := 1
      got := len(v.Cve.Metrics.CvssMetricV31)
      if got != exp {
        t.Fatalf("len: got %d, exp %d", got, exp)
      }
    }

    // get first v31 metric
    m := v.Cve.Metrics.CvssMetricV31[0]

    // check source
    t.Run("Source", func(t *testing.T) {
      exp := "nvd@nist.gov"
      got := m.Source
      if got != exp {
        t.Fatalf("got %s, exp %s", got, exp)
      }
    })

    // check metric type
    t.Run("Type", func(t *testing.T) {
      exp := Primary
      got := m.Type
      if got != exp {
        t.Fatalf("got %v, exp %v", got, exp)
      }
    })

    t.Run("CvssData", func(t *testing.T) {
      // get cvss data
      c := m.CvssData

      // check version
      t.Run("Version", func(t *testing.T) {
        var exp cvss31.Version
        got := c.Version
        if got != exp {
          t.Fatalf("got %v, exp %v", got, exp)
        }
      })

      // check vector string
      t.Run("VectorString", func(t *testing.T) {
        exp := "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"
        got := c.VectorString
        if got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check attack vector component
      t.Run("AttackVector", func(t *testing.T) {
        exp := cvss31.AVNetwork
        got := c.AttackVector
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check attack complexity component
      t.Run("AttackComplexity", func(t *testing.T) {
        exp := cvss31.ACLow
        got := c.AttackComplexity
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check privileges required component
      t.Run("PrivilegesRequired", func(t *testing.T) {
        exp := cvss31.PRNone
        got := c.PrivilegesRequired
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check user interaction component
      t.Run("UserInteraction", func(t *testing.T) {
        exp := cvss31.UINone
        got := c.UserInteraction
        if got == nil || *got != exp {
          t.Fatalf(": got %s, exp %s", got, exp)
        }
      })

      // check scope component
      t.Run("Scope", func(t *testing.T) {
        exp := cvss31.SUnchanged
        got := c.Scope
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check confidentialy impact component
      t.Run("ConfidentialityImpact", func(t *testing.T) {
        exp := cvss31.CHigh
        got := c.ConfidentialityImpact
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check integrity impact component
      t.Run("IntegrityImpact", func(t *testing.T) {
        exp := cvss31.CHigh
        got := c.IntegrityImpact
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check availability impact component
      t.Run("AvailabilityImpact", func(t *testing.T) {
        exp := cvss31.CHigh
        got := c.AvailabilityImpact
        if got == nil || *got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check base score
      t.Run("BaseScore", func(t *testing.T) {
        exp := cvss.MustParseScore(9.8)
        got := c.BaseScore
        if got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check base severity
      t.Run("BaseSeverity", func(t *testing.T) {
        exp := cvss.Critical
        got := c.BaseSeverity
        if got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })
    })

    // check exploitibility score
    t.Run("ExploitabilityScore", func(t *testing.T) {
      exp := cvss.MustParseScore(3.9)
      got := *m.ExploitabilityScore
      if got != exp {
        t.Fatalf("got %s, exp %s", got, exp)
      }
    })

    // check impact score
    t.Run("ImpactScore", func(t *testing.T) {
      exp := cvss.MustParseScore(5.9)
      got := *m.ImpactScore
      if got != exp {
        t.Fatalf("got %s, exp %s", got, exp)
      }
    })

    t.Run("Weaknesses", func(t *testing.T) {
      {
        // check weakness length
        exp := 1
        got := len(v.Cve.Weaknesses)
        if got != exp {
          t.Fatalf("len: got %d, exp %d", got, exp)
        }
      }

      // get first weakness
      w := v.Cve.Weaknesses[0]

      // check weakness source
      t.Run("Source",func (t *testing.T) {
        exp := "nvd@nist.gov"
        got := w.Source
        if got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      // check weakness type
      t.Run("Type",func (t *testing.T) {
        exp := "Primary"
        got := w.Type
        if got != exp {
          t.Fatalf("got %s, exp %s", got, exp)
        }
      })

      {
        // check weakness description length
        exp := 1
        got := len(w.Description)
        if got != exp {
            t.Fatalf("got %d, exp %d", got, exp)
        }
      }

      t.Run("Description",func (t *testing.T) {
        exp := LangString { Lang: "en", Value: "CWE-22" }
        got := w.Description[0]

        if !reflect.DeepEqual(got, exp) {
          t.Fatalf("got %v, exp %v", got, exp)
        }
      })
    })

    t.Run("Configurations", func(t *testing.T) {
      {
        // check configurations length
        exp := 1
        got := len(v.Cve.Configurations)
        if got != exp {
          t.Fatalf("len: got %d, exp %d", got, exp)
        }
      }

      t.Run("Nodes", func(t *testing.T) {
        {
          // check configurations length
          exp := 1
          got := len(v.Cve.Configurations[0].Nodes)
          if got != exp {
            t.Fatalf("len: got %d, exp %d", got, exp)
          }
        }

        // get node
        node := v.Cve.Configurations[0].Nodes[0]

        t.Run("Operator", func(t *testing.T) {
          exp := Or
          got := node.Operator
          if got != exp {
            t.Fatalf("got %s, exp %s", got, exp)
          }
        })

        t.Run("Negate", func(t *testing.T) {
          exp := false
          got := node.Negate
          if got != exp {
            t.Fatalf("got %v, exp %v", got, exp)
          }
        })

        t.Run("CpeMatch", func(t *testing.T) {
          {
            // check CpeMatch length
            exp := 1
            got := len(node.CpeMatch)
            if got != exp {
              t.Fatalf("len: got %d, exp %d", got, exp)
            }
          }

          // get cpematch
          match := node.CpeMatch[0]

          // check Vulnerable
          t.Run("Vulnerable", func(t *testing.T) {
            exp := true
            got := match.Vulnerable
            if got != exp {
              t.Fatalf("got %v, exp %v", got, exp)
            }
          })

          // check Criteria
          t.Run("Criteria", func(t *testing.T) {
            exp := "cpe:2.3:a:backclick:backclick:5.9.63:*:*:*:professional:*:*:*"
            got := match.Criteria
            if got != exp {
              t.Fatalf("got %s, exp %s", got, exp)
            }
          })

          // check MatchCriteriaId
          t.Run("MatchCriteriaId", func(t *testing.T) {
            exp := uuid.MustParse("0E17FA20-4500-435D-8F99-58317752E37D")
            got := match.MatchCriteriaId
            if got != exp {
              t.Fatalf("got %v, exp %v", got, exp)
            }
          })
        })
      })
    })

    t.Run("References", func(t *testing.T) {
      // TODO: references
      {
        // check references length
        exp := 2
        got := len(v.Cve.References)
        if got != exp {
          t.Fatalf("len: got %d, exp %d", got, exp)
        }
      }

      // expected references
      expRefs := []struct { url, source string; tags []string } {{
        url: "https://www.syss.de/fileadmin/dokumente/Publikationen/Advisories/SYSS-2022-031.txt",
        source: "cve@mitre.org",
        tags: []string { "Exploit", "Third Party Advisory" },
      },{
        url: "https://www.syss.de/pentest-blog/vielfaeltige-schwachstellen-in-backclick-professional-syss-2022-026-bis-037",
        source: "cve@mitre.org",
        tags: []string { "Third Party Advisory" },
      }}

      // check expected references
      for i, exp := range(expRefs) {
        // get reference
        ref := v.Cve.References[i]
        got := struct { url, source string; tags []string } {
          url: ref.Url.String(),
          source: ref.Source,
          tags: ref.Tags,
        }

        if !reflect.DeepEqual(got, exp) {
          t.Fatalf("got %#v, exp %#v", got, exp)
        }
      }
    })
  })
}
